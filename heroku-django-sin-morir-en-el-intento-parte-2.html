<!DOCTYPE html>
<html lang="es">

<head>
  <!-- ## for client-side less
  <link rel="stylesheet/less" type="text/css" href="http://iferminmontilla.com/theme/css/style.less">
  <script src="http://cdnjs.cloudflare.com/ajax/libs/less.js/1.7.3/less.min.js" type="text/javascript"></script>
  -->
  <link rel="stylesheet" type="text/css" href="http://iferminmontilla.com/theme/css/style.css">
  <link rel="stylesheet" type="text/css" href="http://iferminmontilla.com/theme/css/pygments.css">
  <link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=PT+Sans|PT+Serif|PT+Mono">

  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="author" content="Israel Fermín Montilla">
  <meta name="description" content="Posts and writings by Israel Fermín Montilla">

  <link href="http://iferminmontilla.com/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="@#$%_ Atom" />

<meta name="keywords" content="heroku, herramientas, tecnología, programación">

  <title>
    @#$%_
&ndash; Heroku + Django sin morir en el intento (Parte 2)  </title>

<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-55459920-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
</head>

<body>
  <aside>
    <div id="user_meta">
      <a href="http://iferminmontilla.com">
        <img src="http://www.gravatar.com/avatar/d380e571e1a0012794af170fe48a5e65.png" alt="logo">
      </a>
      <h2><a href="http://iferminmontilla.com">Israel Fermín Montilla</a></h2>
      <p>Programación y cuestiones humanas</p>
      <ul>
        <li><a href="http://twitter.com/iferminm" target="_blank">Twitter</a></li>
        <li><a href="http://www.linkedin.com/profile/view?id=66587805&trk=tab_pro" target="_blank">LinkedIn</a></li>
        <li><a href="http://stackoverflow.com/users/1157389/israelord" target="_blank">StackOverflow</a></li>
        <li><a href="https://github.com/iferminm" target="_blank">GitHub</a></li>
      </ul>
    </div>
  </aside>

  <main>
    <header>
      <p>
      <a href="http://iferminmontilla.com">Index</a> &brvbar; <a href="http://iferminmontilla.com/archives.html">Archives</a>
      &brvbar; <a href="http://iferminmontilla.com/feeds/all.atom.xml">Atom</a>
      </p>
    </header>

<article>
  <div class="article_title">
    <h3><a href="http://iferminmontilla.com/heroku-django-sin-morir-en-el-intento-parte-2.html">Heroku + Django sin morir en el intento (Parte 2)</a></h3>
  </div>
  <div class="article_text">
    <p>En el artículo anterior, hablamos de IaaS y de PaaS y de cómo se diferencian
concluimos que <em>Heroku</em> es PaaS, además, expusimos algunas de las limitaciones
que nos impone la plataforma para desplegar nuestras aplicaciones y cómo trabajar
alrededor de ellas para hacer funcionar todo.</p>
<p>Muchas veces, quizás por inocentes o inexpertos, tendemos a hacer todo en la vista
(y hablo de vistas de <em>django</em>), por ejemplo, necesitamos enviar algo al servidor
donde hosteamos las imágenes, simplemente hacemos ejecutamos ese request en la vista,
necesitamos enviar un correo electrónico de confirmación, nada, lo enviamos en la vista,
necesitamos procesar una imagen para reducir la calidad y que ocupe menos espacio en
el servidor donde la vamos a hostear, dale... en la vista.</p>
<p>Bueno, exagero un poco, quizás no en la vista, si somos estrictos con nuestro código,
escribiremos una función que suba la foto al servidor, otra que envíe el correo y otra
que procese la imagen para reducir el tamaño y llamaremos todo desde la vista. Este
enfoque sigue estando errado y, a continuación, voy a explicar por qué.</p>
<p>Todos venimos de hacer proyectos en la universidad, algunos más difíciles que otros,
en algún proyecto, seguramente nos tocó realizar llamadas a alguna <em>API REST</em>, o
enviar algún archivo a un servidor remoto, en todos los casos, estoy seguro de que
todos hicimos lo mismo, una función que se ejecuta cuando enviamos el formulario y
hace todo en línea: llamadas remotas, envío de archivos, envío de correos, etc.</p>
<p>No es incorrecto, funciona, pero ¿cuánto tardó la página siguiente en cargar?, la
pregunta más adecuada sería ¿cuánto tiempo tardó la función en redirigirme a la
siguiente página?, calculemos unos 3 a 5 segundos por llamada remota y unos 2 a 3
segundos, total, alrededor de 15 segundos en redirigir, a eso hay que sumarle
el tiempo de carga de la página siguiente.</p>
<p>Particularmente, mi primer trabajo fue en el mundo de los ERP, es una historia
totalmente distinta, si una persona manda a generar un reporte que tarda 4 horas
en ejecutarse y para ello el programa se bloquea y no le permite hacer más nada,
simplemente no tiene otra opción más que esperar las 4 horas sentado en su escritorio,
ir a tomarse un café, bajar a fumar un cigarrillo hasta que esté listo.</p>
<p>Cuando programas para web, debes tomar en cuenta que debes ser gentil con el usuario
y no hacerlo esperar, tu página debe responder rápido, sino, hay muchas otras páginas
que hacen lo mismo y el usuario simplemente tiene que regresar a la pestaña del navegador
donde está su búsqueda en google y seleccionar otro resultado. Una buena <em>rule of thumb</em>
a la hora de ejecutar operaciones pesadas, como todas las que incluyan llamadas remotas
o procesamiento de imágenes, es realizarlas de manera asíncrona, para ello debemos
valernos de <em>algo</em> que nos permita retrasar la ejecución de una tarea.</p>
<p>Por un lado, necesitaremos algo que nos sirga para mantener una cola de tareas pendientes
por ejecutar, por otro lado necesitamos algo que vaya leyendo esas tareas y ejecutándolas,
la manera más simple de hacerlo en <em>Python</em> es con una librería llamada <em>python-rq</em> y
usando <em>Redis</em> como backend de tareas, es muy fácil de configurar y súper sencilla de usar
para la mayoría de proyectos pequeños a medianos funcionará bastante bien. Para proyectos
a mayor escala, quizás lo mejor sea utilizar <em>celery</em> con <em>RabbitMQ</em> como broker de mensajes.
Hay muchas herramientas que podemos usar como backend de mensajes: Redis, RabbitMQ, ZeroMQ,
Kafka, HornetQ... es cuestión de evaluarlas y ver cuál se ajusta más al proyecto en cuestión
en el cual estamos trabajando.</p>
<p>Como todo en <em>django</em>, tenemos un paquete llamado <em>django-rq</em> que nos ayuda a organizar
el código de una mejor manera y nos hace la vida más fácil, empecemos por descargar
las librerías y paquetes necesarias:</p>
<div class="highlight"><pre>sudo aptitude install redis-server
pip install django-rq django
</pre></div>
<p>Si estamos en <em>Heroku</em>, no es necesario instalar <em>redis</em>, simplemente agregar los nuevos
paquetes Python al <em>requirements.txt</em> para que sean instalados al hacer <em>push</em></p>
<p>Para poder agregar trabajos a las colas, debemos declararlas para que <em>django-rq</em> las
reconozca, simplemente agregamos una nueva variable en nuestro <em>settings.py</em>. A continuación
un ejemplo de configuración para <em>django_rq</em>, la cola <em>default</em> es un ejemplo para desarrollo,
la cola <em>high</em> es un ejemplo de configuración para Heroku si estamos usando el <em>add on</em> de
<em>Redis To Go</em>.</p>
<div class="highlight"><pre><span class="n">RQ_QUEUES</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">&#39;default&#39;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s">&#39;HOST&#39;</span><span class="p">:</span> <span class="s">&#39;localhost&#39;</span><span class="p">,</span>
        <span class="s">&#39;PORT&#39;</span><span class="p">:</span> <span class="mi">6379</span><span class="p">,</span>
        <span class="s">&#39;DB&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
    <span class="p">},</span>
    <span class="s">&#39;high&#39;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s">&#39;HOST&#39;</span><span class="p">:</span> <span class="n">os</span><span class="o">.</span><span class="n">getenv</span><span class="p">(</span><span class="s">&#39;REDISTOGO_URL&#39;</span><span class="p">),</span>
        <span class="s">&#39;PORT&#39;</span><span class="p">:</span> <span class="mi">6379</span><span class="p">,</span>
        <span class="s">&#39;DB&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>Ahora, las funciones sumamente pesadas pueden ser encoladas en cualquiera de las dos
colas que hemos declarado en <em>settings.py</em>.</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">funcion_sumamente_pesada</span><span class="p">(</span><span class="n">argumento</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
<p>Lo que haremos en nuestra vista es, en vez de llamar a la función directamente, le diremos
a <em>django_rq</em> que agregue el trabajo en la cola que consideremos conveniente.</p>
<div class="highlight"><pre><span class="kn">import</span> <span class="nn">django_rq</span>
<span class="kn">from</span> <span class="nn">helpers</span> <span class="kn">import</span> <span class="n">funcion_sumamente_pesada</span>

<span class="k">def</span> <span class="nf">view</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="c">#...</span>
    <span class="n">queue</span> <span class="o">=</span> <span class="n">django_rq</span><span class="o">.</span><span class="n">get_queue</span><span class="p">(</span><span class="s">&#39;high&#39;</span><span class="p">)</span> <span class="c"># si no indicamos una cola, retorna la cola &#39;default&#39;</span>
    <span class="n">queue</span><span class="o">.</span><span class="n">enqueue</span><span class="p">(</span><span class="n">funcion_sumamente_pesada</span><span class="p">,</span> <span class="n">argumento</span><span class="p">)</span>
</pre></div>
<p>También decorar las funciones que queremos encolar, esto hace que el código se vea un poco más
limpio, pero el efecto es el mismo:</p>
<div class="highlight"><pre><span class="kn">from</span> <span class="nn">django_rq</span> <span class="kn">import</span> <span class="n">job</span>

<span class="nd">@job</span><span class="p">(</span><span class="s">&#39;high&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">funcion_sumamente_pesada</span><span class="p">(</span><span class="n">argumentos</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
<p>Y luego, en la vista:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">view</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="c">#...</span>
    <span class="n">funcion_sumamente_pesada</span><span class="o">.</span><span class="n">delay</span><span class="p">(</span><span class="n">argumento</span><span class="p">)</span>
</pre></div>
<p>Lo que rq hace es tomar el <em>objeto función</em>, serializarlo usando <em>pickle</em> y guardar ese objeto
serializado en redis. Ahora que tenemos el trabajo encolado, necesitamos <em>algo</em> para leerlo de
redis, des-serializarlo y ejecutarlo.</p>
<p>RQ, viene con un worker que podemos ejecutar en un <em>dyno</em> aparte (recuerden agregar la entrada
correspondiente en el <em>Procfile</em> de Heroku), simplemente corremos el siguiente comando
en el terminal para probar localmente:</p>
<div class="highlight"><pre>python manage.py rqworker high default
</pre></div>
<p>En la consola, podemos ver cómo los trabajos se van ejecutando, incluso, si apagamos el worker y
mandamos a encolar algunos trabajos, al ejecutar de nuevo el worker de rq podemos ver como los
va leyendo de redis y los ejecuta.</p>
<div class="section" id="consideraciones-con-objetos-persistentes-en-base-de-datos">
<h2>Consideraciones con objetos persistentes en base de datos</h2>
<p>Bueno, ya sabemos que rq hace un <em>pickle</em> de la función y sus argumentos y envía esa información
a <em>Redis</em> para luego ser leído por el worker, hacer el <em>unpickle</em> y ejecutar el trabajo.</p>
<p>A menudo, necesitamos hacer <em>delay</em> de un trabajo que actúa sobre objetos que persisten en la base
de datos, nuestra primera tentación es simplemente pasar los objetos como argumentos al trabajo.</p>
<p>Ahora, veamos, analicemos qué ocurrirá. Al encolar el trabajo tanto la función como sus argumentos
serán serializados, estos argumentos son objetos que pueden ser modificados. Luego de encolar, supongamos
que modifico uno de los atributos del objeto y lo guardo en la base de datos, luego, al ejecutarse mi trabajo
la función también modifica otro atributo y guarda el objeto en la base de datos.</p>
<p>Lo que va a ocurrir es que, como la referencia que fue serializada al momento de encolar está desactualizada,
la modificación que se hizo luego de encolar no estará reflejada en el objeto luego de ejecutar el trabajo.</p>
<div class="section" id="la-solucion">
<h3>La solución</h3>
<p>Simplemente no pasar objetos persistentes como argumentos, es mucho mejor simplemente dar los
<em>id</em> de base de dato al trabajo y que dentro de la función se ejecute un query para traerlos,
de esta manera evitamos conflictos y dolores de cabeza como el antes descrito.</p>
<p>Espero que esto sea de ayuda, es buena práctica trabajar con colas para trabajos pesados
en cualquier proyecto web, no sólo si estamos corriendo nuestra app en Heroku.</p>
</div>
</div>

  </div>
  <div class="article_meta">
    <p>Posted on: Sat 20 September 2014</p>
    <p>Category: <a href="http://iferminmontilla.com/category/blog.html">Blog</a>
 &ndash; Tags:
      <a href="http://iferminmontilla.com/tag/heroku.html">heroku</a>,      <a href="http://iferminmontilla.com/tag/herramientas.html">herramientas</a>,      <a href="http://iferminmontilla.com/tag/tecnologia.html">tecnología</a>,      <a href="http://iferminmontilla.com/tag/programacion.html">programación</a>    </p>
  </div>

  <div id="article_comments">
    <div id="disqus_thread"></div>
    <script type="text/javascript">
        var disqus_identifier = "heroku-django-sin-morir-en-el-intento-parte-2.html";
        (function() {
             var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
             dsq.src = 'http://iferminmblog.disqus.com/embed.js';
             (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
         })();
    </script>
  </div>

</article>


    <div id="ending_message">
      <p>&copy; Israel Fermín Montilla. Built using <a href="http://getpelican.com" target="_blank">Pelican</a>. Theme by Giulio Fidente on <a href="https://github.com/gfidente/pelican-svbhack" target="_blank">github</a>. Member of the <a href="http://internetdefenseleague.org">Internet Defense League</a>.</p>
    </div>
  </main>
<script type="text/javascript">
  window._idl = {};
  _idl.variant = "banner";
  (function() {
    var idl = document.createElement('script');
    idl.type = 'text/javascript';
    idl.async = true;
    idl.src = ('https:' == document.location.protocol ? 'https://' : 'http://') + 'members.internetdefenseleague.org/include/?url=' + (_idl.url || '') + '&campaign=' + (_idl.campaign || '') + '&variant=' + (_idl.variant || 'banner');
    document.getElementsByTagName('body')[0].appendChild(idl);
  })();
</script>
</body>
</html>