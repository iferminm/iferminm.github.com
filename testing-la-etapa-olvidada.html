<!DOCTYPE html>
<html lang="es">

<head>
  <!-- ## for client-side less
  <link rel="stylesheet/less" type="text/css" href="http://iferminmontilla.com/theme/css/style.less">
  <script src="http://cdnjs.cloudflare.com/ajax/libs/less.js/1.7.3/less.min.js" type="text/javascript"></script>
  -->
  <link rel="stylesheet" type="text/css" href="http://iferminmontilla.com/theme/css/style.css">
  <link rel="stylesheet" type="text/css" href="http://iferminmontilla.com/theme/css/pygments.css">
  <link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=PT+Sans|PT+Serif|PT+Mono">

  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="author" content="Israel Fermín Montilla">
  <meta name="description" content="Posts and writings by Israel Fermín Montilla">

  <link href="http://iferminmontilla.com/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="@#$%_ Atom" />

<meta name="keywords" content="Actitud del Programador, desarrollo de software, informática, metodología, testing">

  <title>
    @#$%_
&ndash; Testing: la etapa olvidada.  </title>

<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-55459920-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
</head>

<body>
  <aside>
    <div id="user_meta">
      <a href="http://iferminmontilla.com">
        <img src="http://www.gravatar.com/avatar/d380e571e1a0012794af170fe48a5e65.png" alt="logo">
      </a>
      <h2><a href="http://iferminmontilla.com">Israel Fermín Montilla</a></h2>
      <p>Programación y cuestiones humanas</p>
      <ul>
        <li><a href="http://twitter.com/iferminm" target="_blank">Twitter</a></li>
        <li><a href="http://www.linkedin.com/profile/view?id=66587805&trk=tab_pro" target="_blank">LinkedIn</a></li>
        <li><a href="http://stackoverflow.com/users/1157389/israelord" target="_blank">StackOverflow</a></li>
        <li><a href="https://github.com/iferminm" target="_blank">GitHub</a></li>
      </ul>
    </div>
  </aside>

  <main>
    <header>
      <p>
      <a href="http://iferminmontilla.com">Index</a> &brvbar; <a href="http://iferminmontilla.com/archives.html">Archives</a>
      &brvbar; <a href="http://iferminmontilla.com/feeds/all.atom.xml">Atom</a>
      </p>
    </header>

<article>
  <div class="article_title">
    <h3><a href="http://iferminmontilla.com/testing-la-etapa-olvidada.html">Testing: la etapa olvidada.</a></h3>
  </div>
  <div class="article_text">
    <p>En esta oportunidad, vengo a hablarles de una etapa del
desarrollo que suele ser olvidada y marginada por la mayoría de los
desarrolladores que conozco: las pruebas. En&nbsp;<a class="reference external" href="http://zava.com.ve">Zava</a>, la compañía en
la que trabajo actualmente, llevamos un tiempo hablando acerca de
usar&nbsp;<a class="reference external" href="http://es.wikipedia.org/wiki/Desarrollo_guiado_por_pruebas">TDD</a>&nbsp;(Test Driven Development o Desarrollo Guiado por Pruebas)
como metodología de desarrollo, en esta metodología, las pruebas
unitarias juegan un papel principal, incluso hasta protagónico, pues son
el motor del desarrollo del proyecto. Aún cuando no es oficial el hecho
de que desarrollaremos utilizando esta metodología, personalmente me
tomé en serio el hecho de probar suerte ejecutando mis tareas de
programación guiadas por pruebas. En general, el flujo de trabajo en TDD
es el siguiente:</p>
<ol class="arabic simple">
<li><strong>Elegir un requerimiento:&nbsp;</strong>dependiendo de la metodología de
gestión de proyecto, será distinto este proceso, en nuestro caso,
implementamos una versión modificada de SCRUM, por lo que lo primero
que se hace es tomar uno de los requerimientos seleccionados para el
sprint que está en desarrollo.</li>
<li><strong>Escribir las pruebas unitarias:&nbsp;</strong>normalmente, el requerimiento
tiene unas características que deben ser cumplidas, estas pruebas
deben asegurarse de que dichas condiciones sean cumplidas. Es decir,
una pieza de código lleva el programa de un estado A, a un estado B,
la prueba deba asegurarse de que el estado B sea alcanzado
completamente.</li>
<li><strong>Escribir la implementación:&nbsp;</strong>lógicamente, si ejecutamos las
pruebas sin la implementación, todas van a fallar. En este paso &quot;se
le pone carne al esqueleto&quot;, es decir, de le agrega cuerpo a las
funcionalidades cuyas pruebas fueron escritas.</li>
<li><strong>Ejecutar las pruebas automatizadas:&nbsp;</strong>una vez codificado, se
corren las pruebas y se realizan ajustas hasta asegurarse de que
todas las pruebas pasan de manera satisfactoria.</li>
<li><strong>Refactor:&nbsp;</strong>se realizan ajustes para eliminar la duplicación,
reducir el acoplamiento y aumentar la cohesión.</li>
<li><strong>Actualizar la lista de requerimientos:&nbsp;</strong>se marca el
requerimiento como terminado.</li>
</ol>
<p>Usualmente el proceso de desarrollo se lleva a cabo al revés, es decir,
primero se escribe la funcionalidad y luego se prueba. El problema de
este enfoque es el siguiente:</p>
<ol class="arabic simple">
<li>Muchas veces por cuestiones de tiempo y prisa por entregar,
simplemente se codifica la funcionalidad y se prueba de manera
empírica y no se deja alguna garantía de que esa pieza de software
funciona de manera correcta.</li>
<li>No se validan todos los casos de prueba, ya sea que se pruebe
utilizando la funcionalidad o escribiendo pruebas unitarias una vez
codificada la pieza que se desea probar.</li>
<li>Quien codifica la funcionalidad sabe lo que está bien y lo que está
mal y, por la prisa de entregar, no validará los casos en los que
sabe que falla pues, dependiendo de la metodología, cuando algo falle
puede retomarse por mantenimiento y bug-fixing.</li>
<li>En equipos de desarrollo pequeños, es el mismo desarrollador quien
escribe las pruebas y si la carga de trabajo es muy alta, no se
prueba de manera correcta.</li>
</ol>
<p>Personalmente me ha ocurrido que al desarrollar primero y escribir las
pruebas después, termino validando únicamente mis casos base, que es lo
que debería ocurrir la mayor parte del tiempo, pero los casos borde
quedan sin ser validados y, cuando llega el momento en que algún usuario
cae dentro de estos casos y el software falla, debo volver sobre esa
funcionalidad que, usualmente, está poco documentada (la documentación
es otra de las etapas olvidadas por nosotros los desarrolladores), la
escribí hace algún tiempo y no recuerdo bien cuál fue la lógica o, peor
aún, la escribió otro desarrollador y no tengo ni la más remota idea de
qué fue lo que hizo y, además, tengo otras cosas que hacer en el
momento, por lo que simplemente terminaba escribiendo un parche
específico para validar lo que estaba ocurriendo en el momento y
solventar el problema particular. Si existía más de un caso borde sin
validar, este proceso se podía repetir N veces. En el poco tiempo que
tengo probando seguir el esquema que propone TDD, mi manera de
enfrentarme a los problemas de desarrollo ha experimentado varios
cambios y he visto las siguientes ventajas:</p>
<ol class="arabic simple">
<li>El escribir las pruebas primero, requiere que tenga muy claro el
requerimiento y las condiciones que deben ser satisfechas, por lo
tanto, empiezo a codificar la funcionalidad con una idea más clara de
lo que debo hacer.</li>
<li>A medida que voy escribiendo las pruebas unitarias y validando los
casos de prueba, surgen casos borde que, quizás, al principio no
había considerado. Al final, tengo una validación completa de mi
código y una mayor seguridad en que lo que hice está bien y funciona.</li>
<li>Al desarrollar la funcionalidad como tal con una idea más clara de lo
que cubre el requerimiento, puedo separar el código en módulos que
ejecuten cada uno de los pasos necesarios para cubrirlo de manera
satisfactoria.</li>
<li>Al tener todos los casos de prueba definidos y, con ello, el
requerimiento bien claro y definido, no escribo código de más,
simplemente me concentro en cubrir la funcionalidad y todo el código
que escribí se utiliza para ello.</li>
<li>La cantidad de bugs en el código que produzco ha reducido
considerablemente.</li>
<li>A la hora de alguna falla, las mismas pruebas me ayudan a cercar el
error.</li>
<li>Si agrego código que rompe una funcionalidad previa, las mismas
pruebas me indican qué está fallando y dónde, por lo que puedo hacer
refactor inmediatamente y &nbsp;hacer mis módulos más ortogonales entre
sí.</li>
<li>Si otro desarrollador debe utilizar lo que yo desarrollé, el código
lo entrego con una garantía de que lo que hace, lo hace bien.</li>
<li>Cumplo con todas las etapas del desarrollo de software y ninguna
queda incompleta.</li>
</ol>
<p>En lo personal, la manera de trabajar que propone TDD me ha funcionado
bastante bien, la única desventaja fue que al inicio de mi experimento
no tenía mucha experiencia con frameworks o librerías para el desarrollo
de pruebas, más allá de algunas pruebas unitarias que hice durante la
universidad en los cursos de Ingeniería del Software utilizando JUnit en
Java, por lo que debí cubrir una curva de aprendizaje. Una vez hecho
esto, todo fluyó mucho más rápido y siento que soy más productivo.
Trataré de publicar un par de tutoriales de las herramientas que he
usado recientemente para ver si motivo a alguien más a utilizarlas y a
tomar un poco más en serio las pruebas de software pues, aunque en la
universidad las mencionan como una etapa importante en algunos cursos,
muy pocas personas en la calle toman realmente en serio este recurso tan
útil.</p>
</p>
  </div>
  <div class="article_meta">
    <p>Posted on: jue 19 julio 2012</p>
    <p>Category: <a href="http://iferminmontilla.com/category/blog.html">Blog</a>
 &ndash; Tags:
      <a href="http://iferminmontilla.com/tag/actitud-del-programador.html">Actitud del Programador</a>,      <a href="http://iferminmontilla.com/tag/desarrollo-de-software.html">desarrollo de software</a>,      <a href="http://iferminmontilla.com/tag/informatica.html">informática</a>,      <a href="http://iferminmontilla.com/tag/metodologia.html">metodología</a>,      <a href="http://iferminmontilla.com/tag/testing.html">testing</a>    </p>
  </div>

  <div id="article_comments">
    <div id="disqus_thread"></div>
    <script type="text/javascript">
        var disqus_identifier = "testing-la-etapa-olvidada.html";
        (function() {
             var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
             dsq.src = 'http://iferminmblog.disqus.com/embed.js';
             (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
         })();
    </script>
  </div>

</article>


    <div id="ending_message">
      <p>&copy; Israel Fermín Montilla. Built using <a href="http://getpelican.com" target="_blank">Pelican</a>. Theme by Giulio Fidente on <a href="https://github.com/gfidente/pelican-svbhack" target="_blank">github</a>. Member of the <a href="http://internetdefenseleague.org">Internet Defense League</a>.</p>
    </div>
  </main>
<script type="text/javascript">
  window._idl = {};
  _idl.variant = "banner";
  (function() {
    var idl = document.createElement('script');
    idl.type = 'text/javascript';
    idl.async = true;
    idl.src = ('https:' == document.location.protocol ? 'https://' : 'http://') + 'members.internetdefenseleague.org/include/?url=' + (_idl.url || '') + '&campaign=' + (_idl.campaign || '') + '&variant=' + (_idl.variant || 'banner');
    document.getElementsByTagName('body')[0].appendChild(idl);
  })();
</script>
</body>
</html>